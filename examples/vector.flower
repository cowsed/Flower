module vector

namespace std_impl{
    const vector_initial_capacity: size_t = 2
    const vector_expansion_ratio: size_t = 2
}
struct Vector<T: any>{
    m_data: owner<T>
    m_length: size_t
    m_capacity: size_t
}

fn Vector<T>() -> Vector<T>{
    return Vector<T>{
        .m_data = unsafe alloc_array<T>(std_impl::vector_initial_capacity),
        .m_length = 0,
        .m_capacity = std_impl::vector_initial_capacity,
    }
}

// copy and move assignments
fn copy<Vector<T>>(vec: Vector<T>) -> Vector<T>{
    unsafe{
        // is unsafe until m_data is written over (alloc array introduces undefined values)
        var new_vec: Vector<T> = {
            .m_data = alloc_array<T>(vec.m_capacity)
            .m_length = vec.m_length
            .m_capacity = vec.m_capacity
        }
        for ((val, index) in v){
            ptr_as_array_set<T>(new_vec.m_data, index, val)
        }
    }
    return new_vec
}

fn move<Vector<T>>(from: Vector<T>) -> Vector<T>{
    unsafe{
        var new_vec: Vector<T> = {
            .m_data = alloc_array<T>(vec.m_capacity)
            .m_length = vec.m_length
            .m_capacity = vec.m_capacity
        }
        for ((val, index) in v){
            ptr_as_array_set<T>(new_vec.m_data, index, val)
        }
    }
    return new_vec
}



fn (v: *Vector<T>) append(val: T){
    if m_length == m_capacity{
        m_data = unsafe realloc_array<T>(m_data, m_length, m_capacity * std_impl::vector_expansion_ratio)
    }
    unsafe ptr_as_array_set<T>(v.m_data, v.m_length, val)
    v.m_length++

    
}

fn (const v: *Vector<T>) length() -> size_t{
    return m_length
}

fn (v: *Vector<T>) operator[](index: size_t | index < v.length()) -> view<T>{
        const el: view<T> = unsafe ptr_as_array_access_as_view<T>(v.m_data, index)
        return el
}

fn main(){
    var v: Vector<u32> = {}
    v.append(1)
    v.append(2)
    v.append(3)

    var v2: Vector<u32> = copy(v) // accessing v is still chill
    var v3: Vector<u32> = move(v) // accessing v is now not allowed
    
    // println(v[5]) // error: (before local reasoning, didnt check requirement(index < v.length)) (after local reasoning, out of bounds error)

    for (val: view<u32> in v3){
        println("val is {}", val)
        val = 2;
    }
    // v3 goes out of scope
    // v2 goes out of scope
    // v goes out of scope 
}